{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction What is Windinator? Windinator is a UI framework to help you create professional and personlized user interfaces for games or applications within Unity3D . It provides tools to manage window flow and navigation as well as tools to create user interfaces through code. Integrate in your Project Windinator works with the built-in Unity UI system, it was built to be compatible with existing workflows and other UI tools. You will need to have TextMeshPro imported inside your project since Windinator uses it for displaying text. What are Windows? A window usually takes over the whole screen. When you create a window within Windinator, it will prepare a Prefab and a Script to go along side it. The prefab will contain a normal canvas that you can customize however you see fit. Once the window is created you can show it at runtime by simply pushing it to the stack: Windinator . Push < Window_Type >(); Later, if you want to close the window you can just pop it: Windinator . Pop (); What are Elements? Elements are optional, you can use your usual methods of creating your menus. But in case you need a more modular, code based approach to your designs then this is for you. Elements can be used to create smaller pieces of UI that you will manually integrate in your UI or use it inside other Elements, or fullscreen interfaces. They will also generate a prefab that will get updated automatically when the code updates. The syntax is very inspired by Flutter. There is no runtime overhead to this approach, all generation happens during editor time and gets saved to a prefab that you can use. Here is an example of what an element file looks like vs what it automatically generates: using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class GoogleTemplate : LayoutBaker { [SerializeField] Sprite m_logo ; public override Element Bake () { return new Vertical ( new Element [] { new Graphic ( sprite : m_logo , color : Colors . OnBackground ), new MaterialUI . Label ( \"Guuglio\" , style : MaterialSize . Headline , fontStyle : TMPro . FontStyles . Bold , color : Colors . OnBackground ), new Spacer ( 25f ), new MaterialUI . InputField ( labelText : \"Search\" , style : MaterialTextFieldType . Filled ), new Spacer ( 25f ), new Horizontal ( children : new Element [] { new MaterialUI . Button ( \"Search\" , type : MaterialButtonType . Text ), new MaterialUI . Button ( \"Feeling Lucky\" , type : MaterialButtonType . Text ) }, alignment : TextAnchor . MiddleCenter , spacing : 20f ) }, alignment : TextAnchor . MiddleCenter ); } } The code above gets translated into this (with a dark theme applied):","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#what-is-windinator","text":"Windinator is a UI framework to help you create professional and personlized user interfaces for games or applications within Unity3D . It provides tools to manage window flow and navigation as well as tools to create user interfaces through code.","title":"What is Windinator?"},{"location":"#integrate-in-your-project","text":"Windinator works with the built-in Unity UI system, it was built to be compatible with existing workflows and other UI tools. You will need to have TextMeshPro imported inside your project since Windinator uses it for displaying text.","title":"Integrate in your Project"},{"location":"#what-are-windows","text":"A window usually takes over the whole screen. When you create a window within Windinator, it will prepare a Prefab and a Script to go along side it. The prefab will contain a normal canvas that you can customize however you see fit. Once the window is created you can show it at runtime by simply pushing it to the stack: Windinator . Push < Window_Type >(); Later, if you want to close the window you can just pop it: Windinator . Pop ();","title":"What are Windows?"},{"location":"#what-are-elements","text":"Elements are optional, you can use your usual methods of creating your menus. But in case you need a more modular, code based approach to your designs then this is for you. Elements can be used to create smaller pieces of UI that you will manually integrate in your UI or use it inside other Elements, or fullscreen interfaces. They will also generate a prefab that will get updated automatically when the code updates. The syntax is very inspired by Flutter. There is no runtime overhead to this approach, all generation happens during editor time and gets saved to a prefab that you can use. Here is an example of what an element file looks like vs what it automatically generates: using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class GoogleTemplate : LayoutBaker { [SerializeField] Sprite m_logo ; public override Element Bake () { return new Vertical ( new Element [] { new Graphic ( sprite : m_logo , color : Colors . OnBackground ), new MaterialUI . Label ( \"Guuglio\" , style : MaterialSize . Headline , fontStyle : TMPro . FontStyles . Bold , color : Colors . OnBackground ), new Spacer ( 25f ), new MaterialUI . InputField ( labelText : \"Search\" , style : MaterialTextFieldType . Filled ), new Spacer ( 25f ), new Horizontal ( children : new Element [] { new MaterialUI . Button ( \"Search\" , type : MaterialButtonType . Text ), new MaterialUI . Button ( \"Feeling Lucky\" , type : MaterialButtonType . Text ) }, alignment : TextAnchor . MiddleCenter , spacing : 20f ) }, alignment : TextAnchor . MiddleCenter ); } } The code above gets translated into this (with a dark theme applied):","title":"What are Elements?"},{"location":"elements/","text":"Elements Creating an Element You can use elements to build your entire or partial UI through code. Upon creation you will have a prefab and a controller script. The prefab will automatically be updated so you don't want to change or add any children, only the root object. The prefab will only be updated once the script is changed. You can force an update by right clicking and selecting Windinator/Re-Bake Selection . Script skeleton using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { public override Element Bake () { return null ; // Place your elements here } // Use your usual Unity callbacks if you need, // aka void Start(), Update(), etc. } Element Settings Free Control : If this is false, the element will be it's preffered size (the size depends on the contents), otherwise you can resize it freely and potentially make it fullscreen. Script References Script references are used to store a reference to one of your elements. All your referenced fields MUST have the SerializeField attribute or be public for them to work. using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { [SerializeField] MaterialLabel m_label ; public override Element Bake () { return new MaterialUI . Label ( \"Hello World\" ) . GetReference ( out m_label ); } void Awake () { m_label . LabelText = \"Changing the label's contents from runtime\" ; } }","title":"Elements"},{"location":"elements/#elements","text":"","title":"Elements"},{"location":"elements/#creating-an-element","text":"You can use elements to build your entire or partial UI through code. Upon creation you will have a prefab and a controller script. The prefab will automatically be updated so you don't want to change or add any children, only the root object. The prefab will only be updated once the script is changed. You can force an update by right clicking and selecting Windinator/Re-Bake Selection .","title":"Creating an Element"},{"location":"elements/#script-skeleton","text":"using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { public override Element Bake () { return null ; // Place your elements here } // Use your usual Unity callbacks if you need, // aka void Start(), Update(), etc. }","title":"Script skeleton"},{"location":"elements/#element-settings","text":"Free Control : If this is false, the element will be it's preffered size (the size depends on the contents), otherwise you can resize it freely and potentially make it fullscreen.","title":"Element Settings"},{"location":"elements/#script-references","text":"Script references are used to store a reference to one of your elements. All your referenced fields MUST have the SerializeField attribute or be public for them to work. using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { [SerializeField] MaterialLabel m_label ; public override Element Bake () { return new MaterialUI . Label ( \"Hello World\" ) . GetReference ( out m_label ); } void Awake () { m_label . LabelText = \"Changing the label's contents from runtime\" ; } }","title":"Script References"},{"location":"extra-ui/","text":"UI Graphics This sections goes over additional components that expand your toolset and will help you create better user interfaces without the need of additional images and graphics. Rectangle Graphic The Rectangle Graphic is a new UI component that renders a simple rectangle that can be costumized in different ways. It uses signed distance fields to render which results in perfect anti-aliased images. To create this element, right click on the hierarchy and select UI->More Shapes->Rectangle . By default it looks like a normal white rectangle but you have a couple more settings to play around with. Outline Settings An outline is just a set of pixels that expands from the graphic. They can be any color and any distance from the border. Outline Size is the number of pixels that the outline will take up on the screen. Shadow Settings Configure how the shadow of this graphic should look. The shadow is always behind the graphic and outline. Shadow Size is the number of pixels that the shadow will take up on the screen. Shadow Blur changes how blury the shadow is, 0 means no blur (essentially the same as an outline). Shadow Power this allows you to change the shadow's blur exponentially. Circle Overlay Circle overlay adds a simple circle that doesn't get out of the graphic's area. This circle was used to create the Material design effect when pressing buttons or cards. In the scene view when the option is expanded you can edit the circle's position and radius using a custom set of controls. Circle Radius is the number of pixels the circle's radius will take. Alpha Multiplier is simply multiplied with the color's alpha value. Circle Pos defines where the circle's center is. Masking Masking allows to cut the image either from the borders or from a rect's position. This is useful if you want to break apart a graphic to make place for text or other artistic intentions. In the scene view when the option is expanded you can edit the mask's rect position and size using a custom set of controls. Gradient The gradient can only be set using 4 colors each representing a corner of the graphic. By default they will be white. Roundness Roundness is also in pixels and defines the curviness of corners. Max Roundess Make the roundness the maximum possible value. Uniform Roundness If ticked, you will only have one value for roundness and the same value will be applied for all corners. Roudness defines the roundess for all or every individual corner in pixels. Polygon Graphic Polygon graphics are essentially the same as the Rectangle graphic except you can add up to 1023 different points to create more complex shapes. This can be easily animated via a custom script to create interesting effects. And here is the same polygon with some styling.","title":"UI Graphics"},{"location":"extra-ui/#ui-graphics","text":"This sections goes over additional components that expand your toolset and will help you create better user interfaces without the need of additional images and graphics.","title":"UI Graphics"},{"location":"extra-ui/#rectangle-graphic","text":"The Rectangle Graphic is a new UI component that renders a simple rectangle that can be costumized in different ways. It uses signed distance fields to render which results in perfect anti-aliased images. To create this element, right click on the hierarchy and select UI->More Shapes->Rectangle . By default it looks like a normal white rectangle but you have a couple more settings to play around with.","title":"Rectangle Graphic"},{"location":"extra-ui/#outline-settings","text":"An outline is just a set of pixels that expands from the graphic. They can be any color and any distance from the border. Outline Size is the number of pixels that the outline will take up on the screen.","title":"Outline Settings"},{"location":"extra-ui/#shadow-settings","text":"Configure how the shadow of this graphic should look. The shadow is always behind the graphic and outline. Shadow Size is the number of pixels that the shadow will take up on the screen. Shadow Blur changes how blury the shadow is, 0 means no blur (essentially the same as an outline). Shadow Power this allows you to change the shadow's blur exponentially.","title":"Shadow Settings"},{"location":"extra-ui/#circle-overlay","text":"Circle overlay adds a simple circle that doesn't get out of the graphic's area. This circle was used to create the Material design effect when pressing buttons or cards. In the scene view when the option is expanded you can edit the circle's position and radius using a custom set of controls. Circle Radius is the number of pixels the circle's radius will take. Alpha Multiplier is simply multiplied with the color's alpha value. Circle Pos defines where the circle's center is.","title":"Circle Overlay"},{"location":"extra-ui/#masking","text":"Masking allows to cut the image either from the borders or from a rect's position. This is useful if you want to break apart a graphic to make place for text or other artistic intentions. In the scene view when the option is expanded you can edit the mask's rect position and size using a custom set of controls.","title":"Masking"},{"location":"extra-ui/#gradient","text":"The gradient can only be set using 4 colors each representing a corner of the graphic. By default they will be white.","title":"Gradient"},{"location":"extra-ui/#roundness","text":"Roundness is also in pixels and defines the curviness of corners. Max Roundess Make the roundness the maximum possible value. Uniform Roundness If ticked, you will only have one value for roundness and the same value will be applied for all corners. Roudness defines the roundess for all or every individual corner in pixels.","title":"Roundness"},{"location":"extra-ui/#polygon-graphic","text":"Polygon graphics are essentially the same as the Rectangle graphic except you can add up to 1023 different points to create more complex shapes. This can be easily animated via a custom script to create interesting effects. And here is the same polygon with some styling.","title":"Polygon Graphic"},{"location":"material-ui/","text":"Material UI To create a new Material element, go under UI->Material->(Pick What You Want) . Palettes Color palettes allow you to easily switch between different styles but also keep a consistent look across all your UI. Out of the box, Windinator comes with 3 styles: Baseline Floral Material3 All of the styles above have their light and dark counter-parts. You can then attach the \"Color Palette\" script to any graphical component and select the color you want to assign. If you tick the box next to the color name, you will be able to put a custom color although this isn't advised. Labels Labels are simple TextMeshPro components with a custom font and predefined set of styles (font sizes). Cards Cards are simple rectangles with rounded corders and some pre-set styles that you can switch between. This just followes Material design guidelines and helps you create consitent looks. Icons Windinator comes with all the Material Design icons built-in. You can simply start typing the icon's name and it will show you all available options. Buttons Buttons have a circle effect when pressed and have some built-in styles: Elevated Filled Tonal Outlined Text Manual (This just stops controling any colors and leaves it up to you) Buttons can also have an optional icon prepended to the text. All of these styles can also be used with Action buttons which are completly rounded and only composed of an icon. Radio, Switches & Checkboxes All of these are controls for selection options. They are all animated and adapt to selected style. Input Fields Input fields have two different styles (filled & outlined) and they can contain an optional icon, label and helper text. They can also be configured to validate a Regex string with an error message for forms.","title":"Material UI"},{"location":"material-ui/#material-ui","text":"To create a new Material element, go under UI->Material->(Pick What You Want) .","title":"Material UI"},{"location":"material-ui/#palettes","text":"Color palettes allow you to easily switch between different styles but also keep a consistent look across all your UI. Out of the box, Windinator comes with 3 styles: Baseline Floral Material3 All of the styles above have their light and dark counter-parts. You can then attach the \"Color Palette\" script to any graphical component and select the color you want to assign. If you tick the box next to the color name, you will be able to put a custom color although this isn't advised.","title":"Palettes"},{"location":"material-ui/#labels","text":"Labels are simple TextMeshPro components with a custom font and predefined set of styles (font sizes).","title":"Labels"},{"location":"material-ui/#cards","text":"Cards are simple rectangles with rounded corders and some pre-set styles that you can switch between. This just followes Material design guidelines and helps you create consitent looks.","title":"Cards"},{"location":"material-ui/#icons","text":"Windinator comes with all the Material Design icons built-in. You can simply start typing the icon's name and it will show you all available options.","title":"Icons"},{"location":"material-ui/#buttons","text":"Buttons have a circle effect when pressed and have some built-in styles: Elevated Filled Tonal Outlined Text Manual (This just stops controling any colors and leaves it up to you) Buttons can also have an optional icon prepended to the text. All of these styles can also be used with Action buttons which are completly rounded and only composed of an icon.","title":"Buttons"},{"location":"material-ui/#radio-switches-checkboxes","text":"All of these are controls for selection options. They are all animated and adapt to selected style.","title":"Radio, Switches &amp; Checkboxes"},{"location":"material-ui/#input-fields","text":"Input fields have two different styles (filled & outlined) and they can contain an optional icon, label and helper text. They can also be configured to validate a Regex string with an error message for forms.","title":"Input Fields"},{"location":"windinator-class/","text":"Windinator.cs","title":"MaterialUI"},{"location":"windinator-class/#windinatorcs","text":"","title":"Windinator.cs"},{"location":"windows/","text":"Windows Creating a Window Once you create a new window, it will generate two files. One prefab which is going to be your UI content. And a controller which is a script with the same name, if no errors happened during creation the controller will automatically be attached to the prefab. To edit the window's content double click the prefab ([W] ExampleWindow) file and start populating your canvas. If you want to show your window during runtime you just have to push it: Windinator . Push < ExampleWindow >(); Window Settings Should Block Game Flow : This lets the system know that you want your game to enter a pause state or impede player controls when this window is open. Can Close Window : If this is enabled your window might be closed by external actions, for example pressing escape or the back button on a mobile phone. Otherwise you are in full control for when it should close (Can only be closed with ForcePopWindow() function). Auto Assign Background : If you are creating a pop-up, this will add a transparent background behind your window automatically. Background Closes Window : If background is assigned, once the user clicks it during runtime it will Pop the current window. Background Color : Customize the background color, the default value of this can be customized via the Windinator Config file. Animated By Default : If true, apply simple fade in/out effect. Transition Anim Duration : Duration of animations. Warmup Count : Windows are recycled to avoid instantiating a new one every single time. This setting will create some copies at startup to avoid freezing during user interaction. Cull Background Windows : If true, any window behind this one will be culled (not rendered). This helps performance. Fixing Linking Issues If you get a missing reference error from Windinator you might have to re-link the window:","title":"Windows"},{"location":"windows/#windows","text":"","title":"Windows"},{"location":"windows/#creating-a-window","text":"Once you create a new window, it will generate two files. One prefab which is going to be your UI content. And a controller which is a script with the same name, if no errors happened during creation the controller will automatically be attached to the prefab. To edit the window's content double click the prefab ([W] ExampleWindow) file and start populating your canvas. If you want to show your window during runtime you just have to push it: Windinator . Push < ExampleWindow >();","title":"Creating a Window"},{"location":"windows/#window-settings","text":"Should Block Game Flow : This lets the system know that you want your game to enter a pause state or impede player controls when this window is open. Can Close Window : If this is enabled your window might be closed by external actions, for example pressing escape or the back button on a mobile phone. Otherwise you are in full control for when it should close (Can only be closed with ForcePopWindow() function). Auto Assign Background : If you are creating a pop-up, this will add a transparent background behind your window automatically. Background Closes Window : If background is assigned, once the user clicks it during runtime it will Pop the current window. Background Color : Customize the background color, the default value of this can be customized via the Windinator Config file. Animated By Default : If true, apply simple fade in/out effect. Transition Anim Duration : Duration of animations. Warmup Count : Windows are recycled to avoid instantiating a new one every single time. This setting will create some copies at startup to avoid freezing during user interaction. Cull Background Windows : If true, any window behind this one will be culled (not rendered). This helps performance.","title":"Window Settings"},{"location":"windows/#fixing-linking-issues","text":"If you get a missing reference error from Windinator you might have to re-link the window:","title":"Fixing Linking Issues"}]}