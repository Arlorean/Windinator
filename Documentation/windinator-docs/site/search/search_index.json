{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Download Windinator Download from the Asset Store . What is Windinator? Windinator is a UI framework to help you create professional and personlized user interfaces for games or applications within Unity3D . It provides tools to manage window flow and navigation as well as tools to create user interfaces through code. Integrate in your Project Windinator works with the built-in Unity UI system, it was built to be compatible with existing workflows and other UI tools. You will need to have TextMeshPro imported inside your project since Windinator uses it for displaying text. What are Windows? A window usually takes over the whole screen. When you create a window within Windinator, it will prepare a Prefab and a Script to go along side it. The prefab will contain a normal canvas that you can customize however you see fit. Once the window is created you can show it at runtime by simply pushing it to the stack: Windinator . Push < Window_Type >(); Later, if you want to close the window you can just pop it: Windinator . Pop (); What are Elements? Elements are optional, you can use your usual methods of creating your menus. But in case you need a more modular, code based approach to your designs then this is for you. Elements can be used to create smaller pieces of UI that you will manually integrate in your UI or use it inside other Elements, or fullscreen interfaces. They will also generate a prefab that will get updated automatically when the code updates. The syntax is very inspired by Flutter. There is no runtime overhead to this approach, all generation happens during editor time and gets saved to a prefab that you can use. Here is an example of what an element file looks like vs what it automatically generates: using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class GoogleTemplate : LayoutBaker { [SerializeField] Sprite m_logo ; public override Element Bake () { return new Vertical ( new Element [] { new Graphic ( sprite : m_logo , color : Colors . OnBackground ), new MaterialUI . Label ( \"Guuglio\" , style : MaterialSize . Headline , fontStyle : TMPro . FontStyles . Bold , color : Colors . OnBackground ), new Spacer ( 25f ), new MaterialUI . InputField ( labelText : \"Search\" , style : MaterialTextFieldType . Filled ), new Spacer ( 25f ), new Horizontal ( children : new Element [] { new MaterialUI . Button ( \"Search\" , type : MaterialButtonType . Text ), new MaterialUI . Button ( \"Feeling Lucky\" , type : MaterialButtonType . Text ) }, alignment : TextAnchor . MiddleCenter , spacing : 20f ) }, alignment : TextAnchor . MiddleCenter ); } } The code above gets translated into this (with a dark theme applied):","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#download-windinator","text":"Download from the Asset Store .","title":"Download Windinator"},{"location":"#what-is-windinator","text":"Windinator is a UI framework to help you create professional and personlized user interfaces for games or applications within Unity3D . It provides tools to manage window flow and navigation as well as tools to create user interfaces through code.","title":"What is Windinator?"},{"location":"#integrate-in-your-project","text":"Windinator works with the built-in Unity UI system, it was built to be compatible with existing workflows and other UI tools. You will need to have TextMeshPro imported inside your project since Windinator uses it for displaying text.","title":"Integrate in your Project"},{"location":"#what-are-windows","text":"A window usually takes over the whole screen. When you create a window within Windinator, it will prepare a Prefab and a Script to go along side it. The prefab will contain a normal canvas that you can customize however you see fit. Once the window is created you can show it at runtime by simply pushing it to the stack: Windinator . Push < Window_Type >(); Later, if you want to close the window you can just pop it: Windinator . Pop ();","title":"What are Windows?"},{"location":"#what-are-elements","text":"Elements are optional, you can use your usual methods of creating your menus. But in case you need a more modular, code based approach to your designs then this is for you. Elements can be used to create smaller pieces of UI that you will manually integrate in your UI or use it inside other Elements, or fullscreen interfaces. They will also generate a prefab that will get updated automatically when the code updates. The syntax is very inspired by Flutter. There is no runtime overhead to this approach, all generation happens during editor time and gets saved to a prefab that you can use. Here is an example of what an element file looks like vs what it automatically generates: using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class GoogleTemplate : LayoutBaker { [SerializeField] Sprite m_logo ; public override Element Bake () { return new Vertical ( new Element [] { new Graphic ( sprite : m_logo , color : Colors . OnBackground ), new MaterialUI . Label ( \"Guuglio\" , style : MaterialSize . Headline , fontStyle : TMPro . FontStyles . Bold , color : Colors . OnBackground ), new Spacer ( 25f ), new MaterialUI . InputField ( labelText : \"Search\" , style : MaterialTextFieldType . Filled ), new Spacer ( 25f ), new Horizontal ( children : new Element [] { new MaterialUI . Button ( \"Search\" , type : MaterialButtonType . Text ), new MaterialUI . Button ( \"Feeling Lucky\" , type : MaterialButtonType . Text ) }, alignment : TextAnchor . MiddleCenter , spacing : 20f ) }, alignment : TextAnchor . MiddleCenter ); } } The code above gets translated into this (with a dark theme applied):","title":"What are Elements?"},{"location":"WindinatorBehaviour-class/","text":"WindinatorBehaviour.cs WindinatorBehaviour is the same as a simple MonoBehaviour except that it contains some extra code to work with the Windinator system. Properties Declaration Description static readonly int AnimationActors Number of animations being played on this window. static readonly bool IsAnimating Is this window being animated? static readonly bool AnimatedByDefault Is this window being animated by default? This reflects the configuration settings . static readonly float AnimationDuration This reflects the configuration settings . static readonly float CullBackgroundWindows This reflects the configuration settings . static readonly AnimationDelegade FadeIn Access the fade in animation delegate. static readonly GameObject GeneratedBackground If automatic window background was selected, this will have a reference to the created GameObject. static readonly CanvasGroup GeneratedBackgroundGroup If background created, this returns the canvas group on the background. static readonly bool ShoudBlockGameFlow Is this window blocking game flow? Functions Declaration Description public void SetCanExit(bool canExit ) If canExit is false, the window can only be closed manually with 'ForcePopWindow'. Otherwise it can be closed by multiple things like the escape key, pressing on the background, etc","title":"WindinatorBehaviour"},{"location":"WindinatorBehaviour-class/#windinatorbehaviourcs","text":"WindinatorBehaviour is the same as a simple MonoBehaviour except that it contains some extra code to work with the Windinator system.","title":"WindinatorBehaviour.cs"},{"location":"WindinatorBehaviour-class/#properties","text":"Declaration Description static readonly int AnimationActors Number of animations being played on this window. static readonly bool IsAnimating Is this window being animated? static readonly bool AnimatedByDefault Is this window being animated by default? This reflects the configuration settings . static readonly float AnimationDuration This reflects the configuration settings . static readonly float CullBackgroundWindows This reflects the configuration settings . static readonly AnimationDelegade FadeIn Access the fade in animation delegate. static readonly GameObject GeneratedBackground If automatic window background was selected, this will have a reference to the created GameObject. static readonly CanvasGroup GeneratedBackgroundGroup If background created, this returns the canvas group on the background. static readonly bool ShoudBlockGameFlow Is this window blocking game flow?","title":"Properties"},{"location":"WindinatorBehaviour-class/#functions","text":"Declaration Description public void SetCanExit(bool canExit ) If canExit is false, the window can only be closed manually with 'ForcePopWindow'. Otherwise it can be closed by multiple things like the escape key, pressing on the background, etc","title":"Functions"},{"location":"dynamic-ui/","text":"Dynamic UI Dynamic UI consists of procedurally generating, blending and unifying multiple shapes. It works very close to how Unity's GUI system works. To access the API you will need to use include Riten . Windinator . Shapes in your file. Examples of application using WebGL: Bouncy Menu Balls Benchmark Lines Benchmark CanvasDrawer To be able to draw your elements we created a MonoBehaviour wrapper called CanvasDrawer . This class will give you a function protype that looks like this: protected override void Draw ( CanvasGraphic canvas , Vector2 size ) CanvasGraphic is where you will draw everything. The size vector is the size of your RectTransform in pixels. Snowman Example To get started add a Dynamic Canvas (this is just another graphic). Now lets create a new script called Snowman and make it inherit CanvasDrawer . using Riten.Windinator.Shapes ; using UnityEngine ; public class Snowman : CanvasDrawer { protected override void Draw ( CanvasGraphic canvas , Vector2 size ) { // Get the max radius we can have without leaving the rect borders float radius = Mathf . Min ( size . x , size . y ) * 0.5f ; float firstRadius = radius * 0.5f ; float secondRadius = radius * 0.3f ; float thirdRadius = radius * 0.2f ; // Vector2.zero will draw at the center, // so to get the bottom position we need to substract the size Vector2 basePosition = new Vector2 ( 0 , - size . y * 0.5f + firstRadius ); Vector2 bodyPosition = basePosition + Vector2 . up * ( firstRadius + secondRadius ); Vector2 headPosition = bodyPosition + Vector2 . up * ( secondRadius + thirdRadius ); // Draw our 3 circles to create the snowman canvas . CircleBrush . Draw ( headPosition , thirdRadius ); canvas . CircleBrush . Draw ( bodyPosition , secondRadius ); canvas . CircleBrush . Draw ( basePosition , firstRadius ); } } Now add this newly created component to your Dynamic Canvas and watch your snowman! Refresh Mode You have three options to choose: Always , calls your Draw function every frame (on Update). Once , your draw function only gets called on Start and if your element changes size. On Dirty , same as Once but you can call this.SetDirty(); to request a redraw. Blending All of the available brushes have a blending parameter you can tweak. Here is how the example above looks with 20 pixels of blending: canvas . CircleBrush . Draw ( headPosition , thirdRadius , 20f ); canvas . CircleBrush . Draw ( bodyPosition , secondRadius , 20f ); canvas . CircleBrush . Draw ( basePosition , firstRadius , 20f ); Draw Operations By default the DrawOperation is always Union . This just adds the shapes together. But you have other operations at your disposal like Substract & Intersect . Here is how it looks if we substract the middle circle from the rest, because of the blending it chips away at the rest of the circles. // Order is significant with operations canvas . CircleBrush . Draw ( headPosition , thirdRadius , 20f ); canvas . CircleBrush . Draw ( basePosition , firstRadius , 20f ); canvas . CircleBrush . Draw ( bodyPosition , secondRadius , 20f , DrawOperation . Substract ); Batching The snowman example will use 3 drawcalls to draw all our snownman. But we can optimize this to only 1! using Riten.Windinator.Shapes ; using UnityEngine ; public class Snowman : CanvasDrawer { [SerializeField] float m_blend = 0f ; protected override void Draw ( CanvasGraphic canvas , Vector2 size ) { float radius = Mathf . Min ( size . x , size . y ) * 0.5f ; float firstRadius = radius * 0.5f ; float secondRadius = radius * 0.3f ; float thirdRadius = radius * 0.2f ; Vector2 basePosition = new Vector2 ( 0 , - size . y * 0.5f + firstRadius ); Vector2 bodyPosition = basePosition + Vector2 . up * ( firstRadius + secondRadius ); Vector2 headPosition = bodyPosition + Vector2 . up * ( secondRadius + thirdRadius ); canvas . CircleBrush . AddBatch ( headPosition , thirdRadius , m_blend ); canvas . CircleBrush . AddBatch ( basePosition , firstRadius , m_blend ); canvas . CircleBrush . AddBatch ( bodyPosition , secondRadius , m_blend ); // The circles only get drawn here! // This will also clear the inner batch content canvas . CircleBrush . DrawBatch ( DrawOperation . Union ); } } Brushes As of the writing of this documentation there are 3 brushes: LineBrush , CircleBrush and RectBrush . More will be added in the future, namely PolygonBrush and BezierBrush are being worked on. They all allow for direct Drawing and batched Drawing. Styling The final result can be tweaked like any SDF Graphics element. Optimizing A quick optimization tip is to play with the quality slider, this will increase FPS exponentially! You can see that even at 2% quality, the Snowman is still visible.","title":"Dynamic Graphics"},{"location":"dynamic-ui/#dynamic-ui","text":"Dynamic UI consists of procedurally generating, blending and unifying multiple shapes. It works very close to how Unity's GUI system works. To access the API you will need to use include Riten . Windinator . Shapes in your file. Examples of application using WebGL: Bouncy Menu Balls Benchmark Lines Benchmark","title":"Dynamic UI"},{"location":"dynamic-ui/#canvasdrawer","text":"To be able to draw your elements we created a MonoBehaviour wrapper called CanvasDrawer . This class will give you a function protype that looks like this: protected override void Draw ( CanvasGraphic canvas , Vector2 size ) CanvasGraphic is where you will draw everything. The size vector is the size of your RectTransform in pixels.","title":"CanvasDrawer"},{"location":"dynamic-ui/#snowman-example","text":"To get started add a Dynamic Canvas (this is just another graphic). Now lets create a new script called Snowman and make it inherit CanvasDrawer . using Riten.Windinator.Shapes ; using UnityEngine ; public class Snowman : CanvasDrawer { protected override void Draw ( CanvasGraphic canvas , Vector2 size ) { // Get the max radius we can have without leaving the rect borders float radius = Mathf . Min ( size . x , size . y ) * 0.5f ; float firstRadius = radius * 0.5f ; float secondRadius = radius * 0.3f ; float thirdRadius = radius * 0.2f ; // Vector2.zero will draw at the center, // so to get the bottom position we need to substract the size Vector2 basePosition = new Vector2 ( 0 , - size . y * 0.5f + firstRadius ); Vector2 bodyPosition = basePosition + Vector2 . up * ( firstRadius + secondRadius ); Vector2 headPosition = bodyPosition + Vector2 . up * ( secondRadius + thirdRadius ); // Draw our 3 circles to create the snowman canvas . CircleBrush . Draw ( headPosition , thirdRadius ); canvas . CircleBrush . Draw ( bodyPosition , secondRadius ); canvas . CircleBrush . Draw ( basePosition , firstRadius ); } } Now add this newly created component to your Dynamic Canvas and watch your snowman!","title":"Snowman Example"},{"location":"dynamic-ui/#refresh-mode","text":"You have three options to choose: Always , calls your Draw function every frame (on Update). Once , your draw function only gets called on Start and if your element changes size. On Dirty , same as Once but you can call this.SetDirty(); to request a redraw.","title":"Refresh Mode"},{"location":"dynamic-ui/#blending","text":"All of the available brushes have a blending parameter you can tweak. Here is how the example above looks with 20 pixels of blending: canvas . CircleBrush . Draw ( headPosition , thirdRadius , 20f ); canvas . CircleBrush . Draw ( bodyPosition , secondRadius , 20f ); canvas . CircleBrush . Draw ( basePosition , firstRadius , 20f );","title":"Blending"},{"location":"dynamic-ui/#draw-operations","text":"By default the DrawOperation is always Union . This just adds the shapes together. But you have other operations at your disposal like Substract & Intersect . Here is how it looks if we substract the middle circle from the rest, because of the blending it chips away at the rest of the circles. // Order is significant with operations canvas . CircleBrush . Draw ( headPosition , thirdRadius , 20f ); canvas . CircleBrush . Draw ( basePosition , firstRadius , 20f ); canvas . CircleBrush . Draw ( bodyPosition , secondRadius , 20f , DrawOperation . Substract );","title":"Draw Operations"},{"location":"dynamic-ui/#batching","text":"The snowman example will use 3 drawcalls to draw all our snownman. But we can optimize this to only 1! using Riten.Windinator.Shapes ; using UnityEngine ; public class Snowman : CanvasDrawer { [SerializeField] float m_blend = 0f ; protected override void Draw ( CanvasGraphic canvas , Vector2 size ) { float radius = Mathf . Min ( size . x , size . y ) * 0.5f ; float firstRadius = radius * 0.5f ; float secondRadius = radius * 0.3f ; float thirdRadius = radius * 0.2f ; Vector2 basePosition = new Vector2 ( 0 , - size . y * 0.5f + firstRadius ); Vector2 bodyPosition = basePosition + Vector2 . up * ( firstRadius + secondRadius ); Vector2 headPosition = bodyPosition + Vector2 . up * ( secondRadius + thirdRadius ); canvas . CircleBrush . AddBatch ( headPosition , thirdRadius , m_blend ); canvas . CircleBrush . AddBatch ( basePosition , firstRadius , m_blend ); canvas . CircleBrush . AddBatch ( bodyPosition , secondRadius , m_blend ); // The circles only get drawn here! // This will also clear the inner batch content canvas . CircleBrush . DrawBatch ( DrawOperation . Union ); } }","title":"Batching"},{"location":"dynamic-ui/#brushes","text":"As of the writing of this documentation there are 3 brushes: LineBrush , CircleBrush and RectBrush . More will be added in the future, namely PolygonBrush and BezierBrush are being worked on. They all allow for direct Drawing and batched Drawing.","title":"Brushes"},{"location":"dynamic-ui/#styling","text":"The final result can be tweaked like any SDF Graphics element.","title":"Styling"},{"location":"dynamic-ui/#optimizing","text":"A quick optimization tip is to play with the quality slider, this will increase FPS exponentially! You can see that even at 2% quality, the Snowman is still visible.","title":"Optimizing"},{"location":"elements/","text":"Elements Creating an Element You can use elements to build your entire or partial UI through code. Upon creation you will have a prefab and a controller script. The prefab will automatically be updated so you don't want to change or add any children, only the root object. The prefab will only be updated once the script is changed. You can force an update by right clicking and selecting Windinator/Re-Bake Selection . Script skeleton using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { public override Element Bake () { return null ; // Place your elements here } // Use your usual Unity callbacks if you need, // aka void Start(), Update(), etc. } Element Settings Free Control : If this is false, the element will be it's preffered size (the size depends on the contents), otherwise you can resize it freely and potentially make it fullscreen. Script References Script references are used to store a reference to one of your elements. All your referenced fields MUST have the SerializeField attribute or be public for them to work. using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { [SerializeField] MaterialLabel m_label ; public override Element Bake () { return new MaterialUI . Label ( \"Hello World\" ) . GetReference ( out m_label ); } void Awake () { m_label . LabelText = \"Changing the label's contents from runtime\" ; } }","title":"Elements"},{"location":"elements/#elements","text":"","title":"Elements"},{"location":"elements/#creating-an-element","text":"You can use elements to build your entire or partial UI through code. Upon creation you will have a prefab and a controller script. The prefab will automatically be updated so you don't want to change or add any children, only the root object. The prefab will only be updated once the script is changed. You can force an update by right clicking and selecting Windinator/Re-Bake Selection .","title":"Creating an Element"},{"location":"elements/#script-skeleton","text":"using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { public override Element Bake () { return null ; // Place your elements here } // Use your usual Unity callbacks if you need, // aka void Start(), Update(), etc. }","title":"Script skeleton"},{"location":"elements/#element-settings","text":"Free Control : If this is false, the element will be it's preffered size (the size depends on the contents), otherwise you can resize it freely and potentially make it fullscreen.","title":"Element Settings"},{"location":"elements/#script-references","text":"Script references are used to store a reference to one of your elements. All your referenced fields MUST have the SerializeField attribute or be public for them to work. using UnityEngine ; using Riten.Windinator ; using Riten.Windinator.LayoutBuilder ; using Riten.Windinator.Material ; using static Riten . Windinator . LayoutBuilder . Layout ; public class NewElement : LayoutBaker { [SerializeField] MaterialLabel m_label ; public override Element Bake () { return new MaterialUI . Label ( \"Hello World\" ) . GetReference ( out m_label ); } void Awake () { m_label . LabelText = \"Changing the label's contents from runtime\" ; } }","title":"Script References"},{"location":"extra-ui/","text":"SDF Graphics This sections goes over additional components that expand your toolset and will help you create better user interfaces without the need of additional images and graphics. Rectangle Graphic The Rectangle Graphic is a new UI component that renders a simple rectangle that can be costumized in different ways. It uses signed distance fields to render which results in perfect anti-aliased images. To create this element, right click on the hierarchy and select UI->More Shapes->Rectangle . By default it looks like a normal white rectangle but you have a couple more settings to play around with. Outline Settings An outline is just a set of pixels that expands from the graphic. They can be any color and any distance from the border. Outline Size is the number of pixels that the outline will take up on the screen. Shadow Settings Configure how the shadow of this graphic should look. The shadow is always behind the graphic and outline. Shadow Size is the number of pixels that the shadow will take up on the screen. Shadow Blur changes how blury the shadow is, 0 means no blur (essentially the same as an outline). Shadow Power this allows you to change the shadow's blur exponentially. Circle Overlay Circle overlay adds a simple circle that doesn't get out of the graphic's area. This circle was used to create the Material design effect when pressing buttons or cards. In the scene view when the option is expanded you can edit the circle's position and radius using a custom set of controls. Circle Radius is the number of pixels the circle's radius will take. Alpha Multiplier is simply multiplied with the color's alpha value. Circle Pos defines where the circle's center is. Masking Masking allows to cut the image either from the borders or from a rect's position. This is useful if you want to break apart a graphic to make place for text or other artistic intentions. In the scene view when the option is expanded you can edit the mask's rect position and size using a custom set of controls. Gradient The gradient can only be set using 4 colors each representing a corner of the graphic. By default they will be white. Roundness Roundness is also in pixels and defines the curviness of corners. Max Roundess Make the roundness the maximum possible value. Uniform Roundness If ticked, you will only have one value for roundness and the same value will be applied for all corners. Roudness defines the roundess for all or every individual corner in pixels. Polygon Graphic Polygon graphics are essentially the same as the Rectangle graphic except you can add up to 1023 different points to create more complex shapes. This can be easily animated via a custom script to create interesting effects. And here is the same polygon with some styling.","title":"SDF Graphics"},{"location":"extra-ui/#sdf-graphics","text":"This sections goes over additional components that expand your toolset and will help you create better user interfaces without the need of additional images and graphics.","title":"SDF Graphics"},{"location":"extra-ui/#rectangle-graphic","text":"The Rectangle Graphic is a new UI component that renders a simple rectangle that can be costumized in different ways. It uses signed distance fields to render which results in perfect anti-aliased images. To create this element, right click on the hierarchy and select UI->More Shapes->Rectangle . By default it looks like a normal white rectangle but you have a couple more settings to play around with.","title":"Rectangle Graphic"},{"location":"extra-ui/#outline-settings","text":"An outline is just a set of pixels that expands from the graphic. They can be any color and any distance from the border. Outline Size is the number of pixels that the outline will take up on the screen.","title":"Outline Settings"},{"location":"extra-ui/#shadow-settings","text":"Configure how the shadow of this graphic should look. The shadow is always behind the graphic and outline. Shadow Size is the number of pixels that the shadow will take up on the screen. Shadow Blur changes how blury the shadow is, 0 means no blur (essentially the same as an outline). Shadow Power this allows you to change the shadow's blur exponentially.","title":"Shadow Settings"},{"location":"extra-ui/#circle-overlay","text":"Circle overlay adds a simple circle that doesn't get out of the graphic's area. This circle was used to create the Material design effect when pressing buttons or cards. In the scene view when the option is expanded you can edit the circle's position and radius using a custom set of controls. Circle Radius is the number of pixels the circle's radius will take. Alpha Multiplier is simply multiplied with the color's alpha value. Circle Pos defines where the circle's center is.","title":"Circle Overlay"},{"location":"extra-ui/#masking","text":"Masking allows to cut the image either from the borders or from a rect's position. This is useful if you want to break apart a graphic to make place for text or other artistic intentions. In the scene view when the option is expanded you can edit the mask's rect position and size using a custom set of controls.","title":"Masking"},{"location":"extra-ui/#gradient","text":"The gradient can only be set using 4 colors each representing a corner of the graphic. By default they will be white.","title":"Gradient"},{"location":"extra-ui/#roundness","text":"Roundness is also in pixels and defines the curviness of corners. Max Roundess Make the roundness the maximum possible value. Uniform Roundness If ticked, you will only have one value for roundness and the same value will be applied for all corners. Roudness defines the roundess for all or every individual corner in pixels.","title":"Roundness"},{"location":"extra-ui/#polygon-graphic","text":"Polygon graphics are essentially the same as the Rectangle graphic except you can add up to 1023 different points to create more complex shapes. This can be easily animated via a custom script to create interesting effects. And here is the same polygon with some styling.","title":"Polygon Graphic"},{"location":"material-ui/","text":"Material UI To create a new Material element, go under UI->Material->(Pick What You Want) . Palettes Color palettes allow you to easily switch between different styles but also keep a consistent look across all your UI. Out of the box, Windinator comes with 3 styles: Baseline Floral Material3 All of the styles above have their light and dark counter-parts. You can then attach the \"Color Palette\" script to any graphical component and select the color you want to assign. If you tick the box next to the color name, you will be able to put a custom color although this isn't advised. Labels Labels are simple TextMeshPro components with a custom font and predefined set of styles (font sizes). Cards Cards are simple rectangles with rounded corders and some pre-set styles that you can switch between. This just followes Material design guidelines and helps you create consitent looks. Icons Windinator comes with all the Material Design icons built-in. You can simply start typing the icon's name and it will show you all available options. Buttons Buttons have a circle effect when pressed and have some built-in styles: Elevated Filled Tonal Outlined Text Manual (This just stops controling any colors and leaves it up to you) Buttons can also have an optional icon prepended to the text. All of these styles can also be used with Action buttons which are completly rounded and only composed of an icon. Radio, Switches & Checkboxes All of these are controls for selection options. They are all animated and adapt to selected style. Input Fields Input fields have two different styles (filled & outlined) and they can contain an optional icon, label and helper text. They can also be configured to validate a Regex string with an error message for forms.","title":"Material UI"},{"location":"material-ui/#material-ui","text":"To create a new Material element, go under UI->Material->(Pick What You Want) .","title":"Material UI"},{"location":"material-ui/#palettes","text":"Color palettes allow you to easily switch between different styles but also keep a consistent look across all your UI. Out of the box, Windinator comes with 3 styles: Baseline Floral Material3 All of the styles above have their light and dark counter-parts. You can then attach the \"Color Palette\" script to any graphical component and select the color you want to assign. If you tick the box next to the color name, you will be able to put a custom color although this isn't advised.","title":"Palettes"},{"location":"material-ui/#labels","text":"Labels are simple TextMeshPro components with a custom font and predefined set of styles (font sizes).","title":"Labels"},{"location":"material-ui/#cards","text":"Cards are simple rectangles with rounded corders and some pre-set styles that you can switch between. This just followes Material design guidelines and helps you create consitent looks.","title":"Cards"},{"location":"material-ui/#icons","text":"Windinator comes with all the Material Design icons built-in. You can simply start typing the icon's name and it will show you all available options.","title":"Icons"},{"location":"material-ui/#buttons","text":"Buttons have a circle effect when pressed and have some built-in styles: Elevated Filled Tonal Outlined Text Manual (This just stops controling any colors and leaves it up to you) Buttons can also have an optional icon prepended to the text. All of these styles can also be used with Action buttons which are completly rounded and only composed of an icon.","title":"Buttons"},{"location":"material-ui/#radio-switches-checkboxes","text":"All of these are controls for selection options. They are all animated and adapt to selected style.","title":"Radio, Switches &amp; Checkboxes"},{"location":"material-ui/#input-fields","text":"Input fields have two different styles (filled & outlined) and they can contain an optional icon, label and helper text. They can also be configured to validate a Regex string with an error message for forms.","title":"Input Fields"},{"location":"windinator-class/","text":"Windinator.cs Properties Declaration Description static readonly int WindowCount Gets the number of pushed windows. static readonly bool IsEmpty Is the window stack empty. Same thing as checking if WindowCount is 0. static readonly Canvas Canvas Get root canvas, this canvas holds all other windows. If no window was ever pushed, this value can be null static readonly bool ShoudBlockGameFlow Use this to block input for your player controllers when true. Stack Management Functions Declaration Description static Push < T >(AnimationDelegade?) Pushes a window of type T to the stack. This will instantiate or pool the window and animate it if specified. static PushPrefab (WindinatorBehaviour, AnimationDelegade?) Same as Push, except it accepts a reference to a WindinatorBehaviour prefab (this reference has to be from your projects folder, not from your scene). static Pop (bool? force , AnimationDelegade?) This will Pop (remove) the top most window, which is usually the active window. If the window can't be closed it won't do anything unless force is true. static MoveToTop (WindinatorBehaviour) This will move the window reference to the top of the stack. This affects rendering order and input priotity. static Replace < T >(WindinatorBehaviour) Same as Push but it will automatically remove the top most window. Manual Animation Management Declaration Description static Animate (WindinatorBehaviour, AnimationDelegade, Action? onDone ) Plays animation for window instance based on its config settings. Once animation finishes, onDone callback will be invoked. static ClearAnimations (WindinatorBehaviour) If there are any animations being played for the specified window, stop them and don't invoke onDone callback. Helpful Functions Declaration Description static bool Warmup () Warmup the Windinator system. This will create the root Canvas, create all the window pools and get the reference to the WindinatorConfig resource file. static RunNextFrame (Action?) Simply queue an Action that will be executed one time next frame and then discarded. This will warmup the system if it wasn't already. static Color GetColor (Colors) Convert Material Color to Unity3D Color, a preffered way of doing it would be: Colors.Background.ToColor() which has the same effect. static GameObject GetElementPrefab < T >() Accepts a LayoutBaker type and returns its corresponding Prefab. Use it to Instantiate other copies. static SetupCanvas (Canvas, CanvasScaler) Configure the canvas and canvas scaler based on the WindinatorConfig resource file settings. static UpdateVisibility () Force Windindator to recheck which windows are visible or not. A window is not visible if another window that culls background windows is in front of it.","title":"MaterialUI"},{"location":"windinator-class/#windinatorcs","text":"","title":"Windinator.cs"},{"location":"windinator-class/#properties","text":"Declaration Description static readonly int WindowCount Gets the number of pushed windows. static readonly bool IsEmpty Is the window stack empty. Same thing as checking if WindowCount is 0. static readonly Canvas Canvas Get root canvas, this canvas holds all other windows. If no window was ever pushed, this value can be null static readonly bool ShoudBlockGameFlow Use this to block input for your player controllers when true.","title":"Properties"},{"location":"windinator-class/#stack-management-functions","text":"Declaration Description static Push < T >(AnimationDelegade?) Pushes a window of type T to the stack. This will instantiate or pool the window and animate it if specified. static PushPrefab (WindinatorBehaviour, AnimationDelegade?) Same as Push, except it accepts a reference to a WindinatorBehaviour prefab (this reference has to be from your projects folder, not from your scene). static Pop (bool? force , AnimationDelegade?) This will Pop (remove) the top most window, which is usually the active window. If the window can't be closed it won't do anything unless force is true. static MoveToTop (WindinatorBehaviour) This will move the window reference to the top of the stack. This affects rendering order and input priotity. static Replace < T >(WindinatorBehaviour) Same as Push but it will automatically remove the top most window.","title":"Stack Management Functions"},{"location":"windinator-class/#manual-animation-management","text":"Declaration Description static Animate (WindinatorBehaviour, AnimationDelegade, Action? onDone ) Plays animation for window instance based on its config settings. Once animation finishes, onDone callback will be invoked. static ClearAnimations (WindinatorBehaviour) If there are any animations being played for the specified window, stop them and don't invoke onDone callback.","title":"Manual Animation Management"},{"location":"windinator-class/#helpful-functions","text":"Declaration Description static bool Warmup () Warmup the Windinator system. This will create the root Canvas, create all the window pools and get the reference to the WindinatorConfig resource file. static RunNextFrame (Action?) Simply queue an Action that will be executed one time next frame and then discarded. This will warmup the system if it wasn't already. static Color GetColor (Colors) Convert Material Color to Unity3D Color, a preffered way of doing it would be: Colors.Background.ToColor() which has the same effect. static GameObject GetElementPrefab < T >() Accepts a LayoutBaker type and returns its corresponding Prefab. Use it to Instantiate other copies. static SetupCanvas (Canvas, CanvasScaler) Configure the canvas and canvas scaler based on the WindinatorConfig resource file settings. static UpdateVisibility () Force Windindator to recheck which windows are visible or not. A window is not visible if another window that culls background windows is in front of it.","title":"Helpful Functions"},{"location":"windows/","text":"Windows Creating a Window Once you create a new window, it will generate two files. One prefab which is going to be your UI content. And a controller which is a script with the same name, if no errors happened during creation the controller will automatically be attached to the prefab. To edit the window's content double click the prefab ([W] ExampleWindow) file and start populating your canvas. If you want to show your window during runtime you just have to push it: Windinator . Push < ExampleWindow >(); Window Settings Should Block Game Flow : This lets the system know that you want your game to enter a pause state or impede player controls when this window is open. Can Close Window : If this is enabled your window might be closed by external actions, for example pressing escape or the back button on a mobile phone. Otherwise you are in full control for when it should close (Can only be closed with ForcePopWindow() function). Auto Assign Background : If you are creating a pop-up, this will add a transparent background behind your window automatically. Background Closes Window : If background is assigned, once the user clicks it during runtime it will Pop the current window. Background Color : Customize the background color, the default value of this can be customized via the Windinator Config file. Animated By Default : If true, apply simple fade in/out effect. Transition Anim Duration : Duration of animations. Warmup Count : Windows are recycled to avoid instantiating a new one every single time. This setting will create some copies at startup to avoid freezing during user interaction. Cull Background Windows : If true, any window behind this one will be culled (not rendered). This helps performance. Fixing Linking Issues If you get a missing reference error from Windinator you might have to re-link the window:","title":"Windows"},{"location":"windows/#windows","text":"","title":"Windows"},{"location":"windows/#creating-a-window","text":"Once you create a new window, it will generate two files. One prefab which is going to be your UI content. And a controller which is a script with the same name, if no errors happened during creation the controller will automatically be attached to the prefab. To edit the window's content double click the prefab ([W] ExampleWindow) file and start populating your canvas. If you want to show your window during runtime you just have to push it: Windinator . Push < ExampleWindow >();","title":"Creating a Window"},{"location":"windows/#window-settings","text":"Should Block Game Flow : This lets the system know that you want your game to enter a pause state or impede player controls when this window is open. Can Close Window : If this is enabled your window might be closed by external actions, for example pressing escape or the back button on a mobile phone. Otherwise you are in full control for when it should close (Can only be closed with ForcePopWindow() function). Auto Assign Background : If you are creating a pop-up, this will add a transparent background behind your window automatically. Background Closes Window : If background is assigned, once the user clicks it during runtime it will Pop the current window. Background Color : Customize the background color, the default value of this can be customized via the Windinator Config file. Animated By Default : If true, apply simple fade in/out effect. Transition Anim Duration : Duration of animations. Warmup Count : Windows are recycled to avoid instantiating a new one every single time. This setting will create some copies at startup to avoid freezing during user interaction. Cull Background Windows : If true, any window behind this one will be culled (not rendered). This helps performance.","title":"Window Settings"},{"location":"windows/#fixing-linking-issues","text":"If you get a missing reference error from Windinator you might have to re-link the window:","title":"Fixing Linking Issues"}]}